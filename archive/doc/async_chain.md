# async chain 

매우 중요한 개념이고 잘 만들면 복잡하지 않은 코드로 분산 처리가 가능하다. 
콜백 없이 하나의 함수에서 처리할 수 있으므로 전체 흐름을 이해하기도 쉽다. 

물론 이와 같은 기능은 많은 비동기 지원 라이브러리에 이미 구현된 기능이다. 
따라서, 잘 살펴서 분산 처리에도 활용할 수 있게 한다. 

## 채널을 사용하는 방법 

요청을 보낼 때 oneshot 채널을 만들고 거기에 await하고, 별도로 백엔드 연결을 관리하는 
태스크에서 채널들을 아이디로 관리해서 응답이 오면 해당 oneshot 채널에 알려주는 
방법이 있다. 

채널 생성과 해제가 빈번할 수 있으므로 좋은 방법인지는 모르겠으나 이런 방법이 필요하다. 

oneshot::channel() 함수에서 생성하는 구조가 크다. 따라서, Future를 관리하는 Future 
형태로 하나의 연결에 대해 요청과 응답을 처리하는 구조를 만들어야 한다. 

## tarpc 

tarpc가 channel, Sink, Stream 등을 사용하여 한 클라이언트에서 여러 요청을 처리하는 
방법을 갖고 있다. RPC의 특성이 그러하다. 따라서, tarpc를 꼼꼼히 살펴서 이해하면 된다. 

매우 좋은 연습문제이다. 답은 있고 좋은 구조를 찾아야 한다. 급하지 않게 완전하게 본다. 
RPC로 만들지는 않는다. 기존의 온라인 게임 분산 처리를 구현한다. 


